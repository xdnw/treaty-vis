var re=Object.defineProperty;var ae=(f,u,y)=>u in f?re(f,u,{enumerable:!0,configurable:!0,writable:!0,value:y}):f[u]=y;var a=(f,u,y)=>ae(f,typeof u!="symbol"?u+"":u,y);(function(){"use strict";new TextEncoder;const f=4096;function u(i,e,t){let n=e;const s=n+t,r=[];let c="";for(;n<s;){const o=i[n++];if((o&128)===0)r.push(o);else if((o&224)===192){const h=i[n++]&63;r.push((o&31)<<6|h)}else if((o&240)===224){const h=i[n++]&63,x=i[n++]&63;r.push((o&31)<<12|h<<6|x)}else if((o&248)===240){const h=i[n++]&63,x=i[n++]&63,p=i[n++]&63;let l=(o&7)<<18|h<<12|x<<6|p;l>65535&&(l-=65536,r.push(l>>>10&1023|55296),l=56320|l&1023),r.push(l)}else r.push(o);r.length>=f&&(c+=String.fromCharCode(...r),r.length=0)}return r.length>0&&(c+=String.fromCharCode(...r)),c}const y=new TextDecoder,P=200;function C(i,e,t){const n=i.subarray(e,e+t);return y.decode(n)}function z(i,e,t){return t>P?C(i,e,t):u(i,e,t)}class S{constructor(e,t){a(this,"type");a(this,"data");this.type=e,this.data=t}}class d extends Error{constructor(e){super(e);const t=Object.create(d.prototype);Object.setPrototypeOf(this,t),Object.defineProperty(this,"name",{configurable:!0,enumerable:!1,value:d.name})}}const g=4294967295;function R(i,e,t){const n=Math.floor(t/4294967296),s=t;i.setUint32(e,n),i.setUint32(e+4,s)}function v(i,e){const t=i.getInt32(e),n=i.getUint32(e+4);return t*4294967296+n}function $(i,e){const t=i.getUint32(e),n=i.getUint32(e+4);return t*4294967296+n}const K=-1,H=4294967296-1,F=17179869184-1;function N({sec:i,nsec:e}){if(i>=0&&e>=0&&i<=F)if(e===0&&i<=H){const t=new Uint8Array(4);return new DataView(t.buffer).setUint32(0,i),t}else{const t=i/4294967296,n=i&4294967295,s=new Uint8Array(8),r=new DataView(s.buffer);return r.setUint32(0,e<<2|t&3),r.setUint32(4,n),s}else{const t=new Uint8Array(12),n=new DataView(t.buffer);return n.setUint32(0,e),R(n,4,i),t}}function V(i){const e=i.getTime(),t=Math.floor(e/1e3),n=(e-t*1e3)*1e6,s=Math.floor(n/1e9);return{sec:t+s,nsec:n-s*1e9}}function q(i){if(i instanceof Date){const e=V(i);return N(e)}else return null}function j(i){const e=new DataView(i.buffer,i.byteOffset,i.byteLength);switch(i.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:{const t=e.getUint32(0),n=e.getUint32(4),s=(t&3)*4294967296+n,r=t>>>2;return{sec:s,nsec:r}}case 12:{const t=v(e,4),n=e.getUint32(0);return{sec:t,nsec:n}}default:throw new d(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${i.length}`)}}function Y(i){const e=j(i);return new Date(e.sec*1e3+e.nsec/1e6)}const X={type:K,encode:q,decode:Y},E=class E{constructor(){a(this,"__brand");a(this,"builtInEncoders",[]);a(this,"builtInDecoders",[]);a(this,"encoders",[]);a(this,"decoders",[]);this.register(X)}register({type:e,encode:t,decode:n}){if(e>=0)this.encoders[e]=t,this.decoders[e]=n;else{const s=-1-e;this.builtInEncoders[s]=t,this.builtInDecoders[s]=n}}tryToEncode(e,t){for(let n=0;n<this.builtInEncoders.length;n++){const s=this.builtInEncoders[n];if(s!=null){const r=s(e,t);if(r!=null){const c=-1-n;return new S(c,r)}}}for(let n=0;n<this.encoders.length;n++){const s=this.encoders[n];if(s!=null){const r=s(e,t);if(r!=null){const c=n;return new S(c,r)}}}return e instanceof S?e:null}decode(e,t,n){const s=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return s?s(e,t,n):new S(t,e)}};a(E,"defaultCodec",new E);let U=E;function G(i){return i instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&i instanceof SharedArrayBuffer}function T(i){return i instanceof Uint8Array?i:ArrayBuffer.isView(i)?new Uint8Array(i.buffer,i.byteOffset,i.byteLength):G(i)?new Uint8Array(i):Uint8Array.from(i)}function A(i){return`${i<0?"-":""}0x${Math.abs(i).toString(16).padStart(2,"0")}`}const J=16,O=16;class Q{constructor(e=J,t=O){a(this,"hit",0);a(this,"miss",0);a(this,"caches");a(this,"maxKeyLength");a(this,"maxLengthPerKey");this.maxKeyLength=e,this.maxLengthPerKey=t,this.caches=[];for(let n=0;n<this.maxKeyLength;n++)this.caches.push([])}canBeCached(e){return e>0&&e<=this.maxKeyLength}find(e,t,n){const s=this.caches[n-1];e:for(const r of s){const c=r.bytes;for(let o=0;o<n;o++)if(c[o]!==e[t+o])continue e;return r.str}return null}store(e,t){const n=this.caches[e.length-1],s={bytes:e,str:t};n.length>=this.maxLengthPerKey?n[Math.random()*n.length|0]=s:n.push(s)}decode(e,t,n){const s=this.find(e,t,n);if(s!=null)return this.hit++,s;this.miss++;const r=u(e,t,n),c=Uint8Array.prototype.slice.call(e,t,t+n);return this.store(c,r),r}}const B="array",w="map_key",D="map_value",W=i=>{if(typeof i=="string"||typeof i=="number")return i;throw new d("The type of key must be string or number but "+typeof i)};class Z{constructor(){a(this,"stack",[]);a(this,"stackHeadPosition",-1)}get length(){return this.stackHeadPosition+1}top(){return this.stack[this.stackHeadPosition]}pushArrayState(e){const t=this.getUninitializedStateFromPool();t.type=B,t.position=0,t.size=e,t.array=new Array(e)}pushMapState(e){const t=this.getUninitializedStateFromPool();t.type=w,t.readCount=0,t.size=e,t.map={}}getUninitializedStateFromPool(){if(this.stackHeadPosition++,this.stackHeadPosition===this.stack.length){const e={type:void 0,size:0,array:void 0,position:0,readCount:0,map:void 0,key:null};this.stack.push(e)}return this.stack[this.stackHeadPosition]}release(e){if(this.stack[this.stackHeadPosition]!==e)throw new Error("Invalid stack state. Released state is not on top of the stack.");if(e.type===B){const n=e;n.size=0,n.array=void 0,n.position=0,n.type=void 0}if(e.type===w||e.type===D){const n=e;n.size=0,n.map=void 0,n.readCount=0,n.type=void 0}this.stackHeadPosition--}reset(){this.stack.length=0,this.stackHeadPosition=-1}}const m=-1,k=new DataView(new ArrayBuffer(0)),ee=new Uint8Array(k.buffer);try{k.getInt8(0)}catch(i){if(!(i instanceof RangeError))throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access")}const _=new RangeError("Insufficient data"),te=new Q;class I{constructor(e){a(this,"extensionCodec");a(this,"context");a(this,"useBigInt64");a(this,"rawStrings");a(this,"maxStrLength");a(this,"maxBinLength");a(this,"maxArrayLength");a(this,"maxMapLength");a(this,"maxExtLength");a(this,"keyDecoder");a(this,"mapKeyConverter");a(this,"totalPos",0);a(this,"pos",0);a(this,"view",k);a(this,"bytes",ee);a(this,"headByte",m);a(this,"stack",new Z);a(this,"entered",!1);this.extensionCodec=(e==null?void 0:e.extensionCodec)??U.defaultCodec,this.context=e==null?void 0:e.context,this.useBigInt64=(e==null?void 0:e.useBigInt64)??!1,this.rawStrings=(e==null?void 0:e.rawStrings)??!1,this.maxStrLength=(e==null?void 0:e.maxStrLength)??g,this.maxBinLength=(e==null?void 0:e.maxBinLength)??g,this.maxArrayLength=(e==null?void 0:e.maxArrayLength)??g,this.maxMapLength=(e==null?void 0:e.maxMapLength)??g,this.maxExtLength=(e==null?void 0:e.maxExtLength)??g,this.keyDecoder=(e==null?void 0:e.keyDecoder)!==void 0?e.keyDecoder:te,this.mapKeyConverter=(e==null?void 0:e.mapKeyConverter)??W}clone(){return new I({extensionCodec:this.extensionCodec,context:this.context,useBigInt64:this.useBigInt64,rawStrings:this.rawStrings,maxStrLength:this.maxStrLength,maxBinLength:this.maxBinLength,maxArrayLength:this.maxArrayLength,maxMapLength:this.maxMapLength,maxExtLength:this.maxExtLength,keyDecoder:this.keyDecoder})}reinitializeState(){this.totalPos=0,this.headByte=m,this.stack.reset()}setBuffer(e){const t=T(e);this.bytes=t,this.view=new DataView(t.buffer,t.byteOffset,t.byteLength),this.pos=0}appendBuffer(e){if(this.headByte===m&&!this.hasRemaining(1))this.setBuffer(e);else{const t=this.bytes.subarray(this.pos),n=T(e),s=new Uint8Array(t.length+n.length);s.set(t),s.set(n,t.length),this.setBuffer(s)}}hasRemaining(e){return this.view.byteLength-this.pos>=e}createExtraByteError(e){const{view:t,pos:n}=this;return new RangeError(`Extra ${t.byteLength-n} of ${t.byteLength} byte(s) found at buffer[${e}]`)}decode(e){if(this.entered)return this.clone().decode(e);try{this.entered=!0,this.reinitializeState(),this.setBuffer(e);const t=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return t}finally{this.entered=!1}}*decodeMulti(e){if(this.entered){yield*this.clone().decodeMulti(e);return}try{for(this.entered=!0,this.reinitializeState(),this.setBuffer(e);this.hasRemaining(1);)yield this.doDecodeSync()}finally{this.entered=!1}}async decodeAsync(e){if(this.entered)return this.clone().decodeAsync(e);try{this.entered=!0;let t=!1,n;for await(const o of e){if(t)throw this.entered=!1,this.createExtraByteError(this.totalPos);this.appendBuffer(o);try{n=this.doDecodeSync(),t=!0}catch(h){if(!(h instanceof RangeError))throw h}this.totalPos+=this.pos}if(t){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return n}const{headByte:s,pos:r,totalPos:c}=this;throw new RangeError(`Insufficient data in parsing ${A(s)} at ${c} (${r} in the current buffer)`)}finally{this.entered=!1}}decodeArrayStream(e){return this.decodeMultiAsync(e,!0)}decodeStream(e){return this.decodeMultiAsync(e,!1)}async*decodeMultiAsync(e,t){if(this.entered){yield*this.clone().decodeMultiAsync(e,t);return}try{this.entered=!0;let n=t,s=-1;for await(const r of e){if(t&&s===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(r),n&&(s=this.readArraySize(),n=!1,this.complete());try{for(;yield this.doDecodeSync(),--s!==0;);}catch(c){if(!(c instanceof RangeError))throw c}this.totalPos+=this.pos}}finally{this.entered=!1}}doDecodeSync(){e:for(;;){const e=this.readHeadByte();let t;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){const s=e-128;if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e<160){const s=e-144;if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else{const s=e-160;t=this.decodeString(s,0)}else if(e===192)t=null;else if(e===194)t=!1;else if(e===195)t=!0;else if(e===202)t=this.readF32();else if(e===203)t=this.readF64();else if(e===204)t=this.readU8();else if(e===205)t=this.readU16();else if(e===206)t=this.readU32();else if(e===207)this.useBigInt64?t=this.readU64AsBigInt():t=this.readU64();else if(e===208)t=this.readI8();else if(e===209)t=this.readI16();else if(e===210)t=this.readI32();else if(e===211)this.useBigInt64?t=this.readI64AsBigInt():t=this.readI64();else if(e===217){const s=this.lookU8();t=this.decodeString(s,1)}else if(e===218){const s=this.lookU16();t=this.decodeString(s,2)}else if(e===219){const s=this.lookU32();t=this.decodeString(s,4)}else if(e===220){const s=this.readU16();if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else if(e===221){const s=this.readU32();if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else if(e===222){const s=this.readU16();if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e===223){const s=this.readU32();if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e===196){const s=this.lookU8();t=this.decodeBinary(s,1)}else if(e===197){const s=this.lookU16();t=this.decodeBinary(s,2)}else if(e===198){const s=this.lookU32();t=this.decodeBinary(s,4)}else if(e===212)t=this.decodeExtension(1,0);else if(e===213)t=this.decodeExtension(2,0);else if(e===214)t=this.decodeExtension(4,0);else if(e===215)t=this.decodeExtension(8,0);else if(e===216)t=this.decodeExtension(16,0);else if(e===199){const s=this.lookU8();t=this.decodeExtension(s,1)}else if(e===200){const s=this.lookU16();t=this.decodeExtension(s,2)}else if(e===201){const s=this.lookU32();t=this.decodeExtension(s,4)}else throw new d(`Unrecognized type byte: ${A(e)}`);this.complete();const n=this.stack;for(;n.length>0;){const s=n.top();if(s.type===B)if(s.array[s.position]=t,s.position++,s.position===s.size)t=s.array,n.release(s);else continue e;else if(s.type===w){if(t==="__proto__")throw new d("The key __proto__ is not allowed");s.key=this.mapKeyConverter(t),s.type=D;continue e}else if(s.map[s.key]=t,s.readCount++,s.readCount===s.size)t=s.map,n.release(s);else{s.key=null,s.type=w;continue e}}return t}}readHeadByte(){return this.headByte===m&&(this.headByte=this.readU8()),this.headByte}complete(){this.headByte=m}readArraySize(){const e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:{if(e<160)return e-144;throw new d(`Unrecognized array type byte: ${A(e)}`)}}}pushMapState(e){if(e>this.maxMapLength)throw new d(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.pushMapState(e)}pushArrayState(e){if(e>this.maxArrayLength)throw new d(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);this.stack.pushArrayState(e)}decodeString(e,t){return!this.rawStrings||this.stateIsMapKey()?this.decodeUtf8String(e,t):this.decodeBinary(e,t)}decodeUtf8String(e,t){var r;if(e>this.maxStrLength)throw new d(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+t+e)throw _;const n=this.pos+t;let s;return this.stateIsMapKey()&&((r=this.keyDecoder)!=null&&r.canBeCached(e))?s=this.keyDecoder.decode(this.bytes,n,e):s=z(this.bytes,n,e),this.pos+=t+e,s}stateIsMapKey(){return this.stack.length>0?this.stack.top().type===w:!1}decodeBinary(e,t){if(e>this.maxBinLength)throw new d(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(e+t))throw _;const n=this.pos+t,s=this.bytes.subarray(n,n+e);return this.pos+=t+e,s}decodeExtension(e,t){if(e>this.maxExtLength)throw new d(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);const n=this.view.getInt8(this.pos+t),s=this.decodeBinary(e,t+1);return this.extensionCodec.decode(s,n,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const e=this.view.getUint8(this.pos);return this.pos++,e}readI8(){const e=this.view.getInt8(this.pos);return this.pos++,e}readU16(){const e=this.view.getUint16(this.pos);return this.pos+=2,e}readI16(){const e=this.view.getInt16(this.pos);return this.pos+=2,e}readU32(){const e=this.view.getUint32(this.pos);return this.pos+=4,e}readI32(){const e=this.view.getInt32(this.pos);return this.pos+=4,e}readU64(){const e=$(this.view,this.pos);return this.pos+=8,e}readI64(){const e=v(this.view,this.pos);return this.pos+=8,e}readU64AsBigInt(){const e=this.view.getBigUint64(this.pos);return this.pos+=8,e}readI64AsBigInt(){const e=this.view.getBigInt64(this.pos);return this.pos+=8,e}readF32(){const e=this.view.getFloat32(this.pos);return this.pos+=4,e}readF64(){const e=this.view.getFloat64(this.pos);return this.pos+=8,e}}function se(i,e){return new I(e).decode(i)}function ne(i){return typeof i=="object"&&i!==null}function ie(i){const e=se(new Uint8Array(i));if(!ne(e))throw new Error("Decoded score payload must be an object");if(Number(e.schema_version)!==2)throw new Error("Score payload schema_version must be 2");const t=Number(e.quantization_scale);if(!Number.isFinite(t)||t<=0)throw new Error("Score payload quantization_scale must be > 0");const n=e.day_keys,s=e.days;if(!Array.isArray(n)||!Array.isArray(s))throw new Error("Score payload day_keys and days must be arrays");if(n.length!==s.length)throw new Error("Score payload day_keys and days length mismatch");const r=[],c={};for(let o=0;o<n.length;o+=1){const h=String(n[o]);if(!/^\d{4}-\d{2}-\d{2}$/.test(h))throw new Error(`Score payload contains invalid day key: ${h}`);if(o>0&&r[o-1]>=h)throw new Error("Score payload day_keys must be strictly ascending");const x=s[o];if(!Array.isArray(x))throw new Error(`Score payload day row must be an array for ${h}`);const p={};for(const l of x){if(!Array.isArray(l)||l.length<2)continue;const L=Number(l[0]),b=Number(l[1]);if(!Number.isFinite(L)||L<=0||!Number.isFinite(b)||b<=0)continue;const M=b/t;!Number.isFinite(M)||M<=0||(p[String(Math.floor(L))]=M)}Object.keys(p).length>0&&(r.push(h),c[h]=p)}return{quantizationScale:t,dayKeys:r,byDay:c}}if(typeof self<"u"&&"addEventListener"in self){const i=self;i.addEventListener("message",e=>{const t=e.data;if(!(!t||t.kind!=="decode"))try{const n=ie(t.payload);i.postMessage({kind:"decode",requestId:t.requestId,ok:!0,runtime:n})}catch(n){i.postMessage({kind:"decode",requestId:t.requestId,ok:!1,error:n instanceof Error?n.message:"Unknown score decode error"})}})}})();
